# Java
My First Java Project Adventure Kensei and practice files

3월 3일 객체지향언어

객체지향
객체(Object)의 사전적 의미:사물(물건),목적(목표),(관심,연구)대상
(외우되 a == b다가 아니라 말로 풀어서 외울수 있도록 한다. - 스토리텔링)

객체지향에서의 객체의 의미
프로그램 세계:
 실행환경,실행되는 것
 프로그램은 실행되기 위해서 메모리에 존재해야한다.
 프로그램을 메모리에 존재시키기 위해서 하는 동작을 로딩(Loading)이라고 한다.
 실행환경 - 메모리
 실행되는 것 - 객체(실세계의 사물/물건/대상을 흉내내어 만든것)

객체지향(Object Oriented):객체를 이용하여 프로그램을 실행시켜도록 하는 것
SmallTalk,C++(포인터,다중상속) -> C#,

OOP(Object Oriented Programming)의 이유
같은 프로그램을 여러 플랫폼(hw,os)에 따라 따로 만드는 수고를 덜기 위해서
(Write Once, Run Anywhere)
Q.왜 자바는 잘 나가는가?
A.인터넷(다양한 컴퓨터 - (Unix, Linux, Windows)) 
 
Java의 장점
1.확장성 - 쉽게 확장 가능(Update,Upgrade) - 상속
2.보안성 - Applet(?)
why? - JVM(JAVA Virtual Machine) :Byte Code의 실행환경
3.이식성 - JVM(JAVA Virtual Machine) :Byte Code의 실행환경
4.재사용성 - OOPL (Object Oriented Programming Language)- 상속과 관련 있음.

자바의 탄생과 특징
자바는 좀더 편한 프로그램 개발환경을 제공한다
-java는 c언어의 포인터처럼 메모리를 직접 접근할수 없다
-java는 객체지향적이다
-능률적이고 분명한 코드를 사용 할 수 있게 해준다
-풍부한 API(Application Programming Interface)를 제공한다

java는 해석환경을 제공한다
-java는 컴파일 방식과 인터프리터 방식의 장점을 취하여 실행된다
*컴파일 방식 - C언어가 대표적,컴파일을 하게되면 실행 파일이 나오게 되어있다.(속도가 인터프리터 방식보다 빠르다)					
*인터프리터 방식 - JavaScript가 대표적,실행파일이 나오지 않고 한줄 한줄 해석하며 실행하는 방식
(사용환경이 바뀌어도 새로 만들지 않아도 된다.)
*두 방식의 장점이 곧 서로의 단점이다. 자바는 두가지의 장점을 모두 갖고 있다(hybrid방식).
-컴파일 후 바이트코드(byte code)생성,바이트코드(.class 파일)는 jvm에서 실행

JVM(Java Virtual Machine) - 자바의 실행 환경
-소스코드(.java파일)을 컴파일 하면 바이트코드가 생성
-바이트코드는 JVM 기반에서 실행되도록 작성한다.
-바이트코드(.class파일)을 JVM이 해석하여 해당 OS에 맞도록 변환해준다
(바이트만 있으면 JVM에 따라 어디에도 사용이 가능하다)
-JVM은 각 OS마다 다른것을 구해서 사용하여야 한다

쓰레드(Thread):사전적 의미- 실타래
-쓰레드:*프로세스 내에서 독립적으로 실행되는 모듈
-쓰레드는 시스템에 부하를 적게 주며,코드나 데이터를 공유
-Java는 쓰레드를 잘 지원한다
*프로세스:OS에서 실행중인 프로그램

가비지 컬랙션(Garbage Collection)
-사용한 메모리 영역 등 하드웨어 자원 반환 의무를 프로그래머 책임에서 해방시킴
-JVM은 갈비지 콜렉터(Garage Collecter)를 내장
-프로그램 실행이 한가할 때 수행되므로 수행 속도에 큰 영향을 미치지 않음
*Garbage - 더이상 사용하지 않는 메모리

공고한 보안(Security)


==========================================
3월 4일 객체지향언어

자바SE 다운로드
  http://www.oracle.com/technetwork/java/javase/downloads/index.html
설치

Java_HOME 환경설정(새로만들기)
JAVA_HOME
:D:\java\jdk1.8.0\

환경변수 수정
Path 수정
%java_home\bin;C:~~~~


JDK 설치확인 cmd 창에서 javac -version명령으로 확인
동작확인

shift + 마우스R  여기서 명령창 실행
확인


==========================================
3월 10일 객체지향언어


 JAVA 소스코드  layout
1. package 선언 - 생략가능,생략시 디폴트 패키지 적용
2. import 선언[들] - java 소스코드에서 사용할 api 선언(java.lang 패키지 임포트 생략 가능)
3. class 선언[들] - public 대표 클래스의 이름으로 파일명 결정

public class Helloworld{ <- 접근한정자 class 클래스명
		//클래스는 속성(property,프로피티)과 메소드로 구성
		//속성이 생략된 클래스
	public static void main(String[] args){
		//메소드 선언:[접근 한정자][static/final] 
						//반환형 메소드형(파라미터[들]{})
		//main method:Java 코드의 시작점,C언어의 main함수

		System.out.println(“Hello World 한글!”);
		//java언어에서 화면 출력 메소드,parametor가 문자열임
	}
}

클래스와 패키지
-클래스란 무엇인가?
 	-java라는 언어는 객체로 이루어 져 있다.
	-객체를 만드는데 꼭 필요한 것이 클래스
	-개발자가 직접 만드는 클래스와 이미 만들어져 제공되는 클래스가 있다

	*객체를 만들기 위해여 정의를 하는것.
	*프로그래머는 자바라는 프로그램의 창조자이며 객체를 만들 수 있다.
	 자바를 만드는 프로그래머는 자바의 객체를 만들기 위해 클래스를 정의한다
	프로그래머는 클래스를 스스로 정의하거나 이미 만들어져 제공되는 클래스를 이용,
	자바가 동작 하도록 하기 위해 객체를 생성한다.	

-패키지란 무엇인가?
	-관련된 클래스들의 묶음
	*마치 폴더와 같다

*책에서 워크 밴치라고 표현 된 것이 있는데 perspective를 지칭하는 것.
*컨텍스트 어웨어 - 컴퓨터는 상황에 대하여 인지하고 판단하여 도움을 준다.

주석
-주석문 3가지
	1. // - 한줄처리 주석문
	2./* 주석문 내용*/ - 여러줄 처리 주석문
	3./**  주석문 내용 */ - 여러줄 처리 주석문 , javadoc을 위한 것.
 *주석 처리 방법: 블럭 지정후 ctrl + shift + /(윈도우)
					 			command + /(맥)


==========================================
3월 17일 객체지향언어

세미 콜론
-한 문장이 끝나는곳에 반드시 붙여야 한다.
-클래스 선언이나 메소드에서는 블록을 나타내는 중괄호{}를 사용

화이트 스페이스
-스페이스(space),탭(tab),개행문자(new line character)를 총칭
-보기 좋은 프로그램은 들여쓰기를 잘해야한다.

들여쓰기
-들여쓰기를 잘하는 방법은 프로그램을 코딩할때 부터 신경쓰는 것
-개발자의 기본 자질이며 매우 중요

명명자(식별자 - identifier)
-명명자:클래스의 이름,매소드의 이름,변수의 이름
-명명자를 만들때 주의사항
	-대소문자를 구분
	-길이의 제한은 없다
	-문자나 Underscore(_),dollar sign($)으로 시작할 수 있다.
	 즉 숫자로 시작하면 안된다는 의미이고,특수문자들 중 위의 두가지만 사용 가능하다
	 (권장하지는 않는다.)

변수의 데이터형
-자바의 변수는 크게 두가지로 구분
	-기본 데이터형
	-객체 데이터형(Reference Type - 참조타입)
	*클래스에의해 정의된 변수는 참조된 변수이다.

변수의 데이터형
-논리형(Boolean - 값이 2개만 존재한다는 의미)
	키워드 	크기 			
	-true		N/A		
	-false		N/A

-문자형(Char)
	키워드  	크기 			
	-char		2byte

-정수형(Intergral)
	키워드		크기
	-byte		1byte
	-short		2byte
	-int		4byte
	-long		8byte
*가장 자주 사용하는것이 int이며 long을 자주 사용하지는 않음
*또한 표현범위를 전부 외울 필요는 없음

-실수형(Floating)
	키워드		크기
	-float		4byte
	-double	8byte
*부동 소수점,고정 소수점 등등이 존재한다
*주로 double을 사용한다.

변수의 데이터형 특징
-논리형
1.참,거짓을 판단하기 위한 변수
2.true,false중 하나만 대입할 수 있다.
3.java에서는 세미불린 개념은 없다.
*boolean b = 1;과 같은 형식을 세미-불린 이라고 하며 javad에서는 사용이 불가능 하다.

-문자형
1.char변수는 2byte문자 수용(한글,일본어등 가능)
2.유니코드(unicode) 지원
3.char 변수로 문자열을 표현할 수 없다.(String 클래스 사용)
*쌍타옴표를 사용할 수 없다. 그냥 따옴표를 사용하여 문자형을 표현하여아 한다.
*’\u0011’같은 경우 16진수의 유니코드값으로 표현한 방법의 예

-정수형
1.정수형은 byte,short,int,long 4가지 타입이 있음
2.표현범위를 넘는 것은 에러가 발생

-실수형
1.실수형은 float,double 2가지타입이 있음
2.실수표현 상수는 모드 double형

변수의 데이터형(Data Type)
-형변환(Type Casting)
	-데이터형을 인위적으로 바꾸는 작업(상향 형변환,하향 형변환)
	-상향 형변환은 자동으로 일어난다
	-하향 형변환은 명시적으로 해야한다:’(데이터형)’형태

Java 코드 개발시 유의사항
-들여쓰기 규칙
	-클래스 이름 생성시: 반드시 대문자로 시작,단어와 단어가 합성될경우 단어의 첫 문자만 대문자

	-인터페이스 이름 생성시:interface도 class의 일종이다. 클래스와 같은 규칙을 따른다

	-메소드 이름 생성시:시작은 소문자로 하되 단어와 단어가 합성된 경우 두번째 문자만 대문자로 표현

	-변수 이름 생성시:메소드와 같은 규칙

	-상수 이름 생성시:모두 대문자로 하되,단어와 단어가 합성된 경우 단어사이에 밑줄을 표시

*키워드는 식별자로 사용 되어서는 안된다.

==========================================
3월 24일 객체지향언어
1.객체 이해하기
객체란 무엇인가
-우리가 알고있는 모든 사물을 의미
-실 세계(real world)에 존재하는 모든 사물
(속성,행위,유일성을 갖고있음)

OOP
-객체들을 프로그램에 그대로 반영하여 시스템을 개발할 수 있는 언어
-실세계의 객체와 객체지향 언어에서 사용되는 객체는 서로 다름
-실제 객체를 프로그램에서 사용할 수 있는 객체로 변환하는 작업
	=>객체 추상화(Object Absrtaction)
-실제 언어에서 사용되는 객체와 언어에서 사용되는 객체는 서로 다르다

객체 추상화(Object Abstraction)
-객체추상화(가능한 필요한 것은 모으고 필요 없는것은 버린다)
	-실제 객체를 프로그램에 적용할 수 있는 형태의 객체로 변형하는 과정
	(추상화의 기본 원리 - 가능한 필요한 것은 모으고 필요 없는것은 버린다)
	-추상화는 어떤 물체에서 주된 특징을 부각시켜 표현하고 나머지 부분은 과감하게 생략하는 것을 의미
	-한 물체를 대표하는 ‘명사(속성)’와’동사(행위)’를 추출하고 이것을 근거로 프로그램에서 사용되는 객체를 생성

-명사와 동사찾기
	-‘부동산 프로그램 개발 가정’
	-관련된 명사(속성)와 동사(행위)만을 찾아낸다

/*
객체지향언어 추상화 해보기
컴퓨터
-명사:OS ,저장소,RAM,CPU,그래픽카드,배터리,액정,가격,제조사
-동사:검색,메모,게임,프로그래밍
*/

(-scan.next().charAt(0);는 입력 받은 앞의 가장 앞자리의 문자형을 확인하는 것이다
 -next():스트링형 객체이며 nextLine()과는 다르게 한번 입력 받은것 아래로는 다시 입력이 불가능하다
 -nextLine():스트링형 객체이며 입력받은것 아래로 입력이 가능하다)

객체 추상화
-UML
-클래스 다이어그램
	-찾아진 명사(속성)와 동사(행위)를 근거로 클래스 다이어그램 생성
	-클래스는 프로그램에서 사용되는(객체)를 만들기 위한 코드
	-붕어빵 틀과 붕어빵
(메서드의 내부는 절차 지향적은 코딩을 하면 된다.)

-클래스다이어그램 만들기
	-접근 제한자 설명과 UML클래스 다이어그램 형테
		-public:어느 클래스나 참조 가능(UML기호:+)
		-protected:같은 pacakge내에서만 참조 가능,자식 클래스의 경우 다른 pacakge에 존재하여도 접근 가능(UML기호:#)
		-default:같은 패키지 내에서만 참조 가능(UML기호:~)
		-private:같은 클래스 내에서만 참조가 가능하다.(UML기호:-)


==========================================
3월 25일 객체지향언어

클래스 다이어그램
+:public
#:protected
~:default
-:private

객체 추상화
-java class만들기
	-클래스 다이어그램을 근거로 코드 개발
	-명사(속성)에 해당하는 것은 변수(virable)로 표현
	-동사(행위)에 해당하는 것은 메서드(method)로 변환

클래스와 객체
-클래스 만들기
	-클래스와 관련된 용어
		-멤버변수
		-멤버메서드
	-객체지향에서 가장 먼저 해야 할 것은 클래스 만들기 이다
	
-객체 만들기
	-클래스(붕어빵틀)를 가지고 객체(붕어)를 만드는 방법
	-‘new’키워드를 사용하여 만드는 방법이 일반적임
	(*C언어에서의 포인터와 같은 개념이다)
클래스명 참조변수명 = new 클래스명();
	Car myCar,yourCar;		//참조변수 선언
	myCar = new Car();		//객체생성
	yourCar = new Car();	//객체생성
	(myCar,yourCar:객체를 참조하는 참조변수)

클래스와 객체
-객체 사용하기
-dot(.)를 이용하여 객체의 멤버에 접근할 수 있다

자바의 특징
1.자바에는 하나의 파일에 여러개의 클래스 정의가 올 수 있다.
2.그러나 반드시 public한 클래스는 하나만 존재해야만 한다.
3.public이 사용된 클래스에는 반드시 파일명과 같은 이름이여야 한다.

변수의 사용범위(SCOPE)
-자바에서는 3가지의 scope 변수가 있다.
	-변수는 프로그램에서 매우 중요한 역할을 차지
	-3가지 타입 변수의 용도와 특징은 반드시 기억
		-지역변수(local)
		-멤버변수(object/instance)
		-전역변수(static / class / global)

1.지역변수
-메서드 내에서 선언된 변수
-생성 시점은 그 메서드가 실행 될 때
-메서드 실행이 다 끝나면 변수는 메모리에서 없어짐
-변수를 사용하는 시점에서 초기화 되어 있지 않으면 컴파일 에러 발생


==========================================
3월 31일 객체지향언어

변수의 사용 범위
지역변수:메서드 내에서 선언 된 변수
	-생성 시점은 그 메서드가 실행 될 때
	-메서드 실행이 다 끝나면 변수는 메모리에서 없어짐
	-변수를 사용하는 시점에서 초기화 되어있지 않으면 컴파일 에러 발생
	 *지역 변수는 초기화 하는 습관을 들여야 한다.

멤버변수
	-메서드 밖에서 선언 된 변수(클래스 안에서)
	-같은 class 안에 있는 모든 멤버 메서드에서 사용 가능
	-멤버변수는 자동적으로 0에 준하는 값으로 초기화
	(숫자 = 0/ 불리언 = false /참조(referance) = null)

전역변수
	-변수명 앞에 static이 붙어있다.

JVM 메모리 구조
-자바의 가상머신
	-자바는 모든 응용프로그램을 JVM을 통해서 실행
	-주요 영역은 3가지로 구성:메서드 영역,스택 영역,힙 영역
	(*Stack:동작하는 개념적  원리,데이터의 임시 저장소
	 스텍의 동작:Last In First Out)
	-메서드의 매개변수(args)는 메서드 내에서 지역변수와 같은 역할을 한다.
	-호출시 Call By Value형식으로 호출한다.
	-String 변수는 객체타입으로  같은 클래스 내에서 여러 변수가 참조할 수 있다.
	

배열
배열이란?
-배열이란 동일한 데이터형 변수의 모음이다.,연속적이다.
-JAVA에서는 배열도 객체로 취급 된다
-배열도 객체라는 말의 의미는 배열이 객체혀애로 존재해야 하며 이 겍체를 가리키는 참조변수도 필요 하다는 것
-배열은 HIP영역의 속성이다

배열 이해햐기
-JAVA에서는 크게 2종류의 배열이 있다.
-기본형 데이터 변수
-객체를 저장하는 배열

기본 데이터형 배열
-기본 데이터형 배열
	-기본 데이터형을 저장하는 배열
	-int[] arr(); :정수형 데이터 형의 값들을 저장할 수 있는 배열 객체를 참조할 참조 변수를 선언
	-주의:C언어와는 다르게 배열의 크기를 지정할 수 없다.

-배열 참조변수 선언 및 배열 객체 선언
	-단지 참조변수 선언 만으로는 배열을 사용할 수 없다
	-따라서 배열객체를 만들어야 한다.
	-바로 “new int[5]”라는 문장이 객체를 만드는 문장이다.
	-배열도 객체이기때문에 반드시 new 키워드를 사용해야 한다
	-“5”의 의미는 5개 정수형 값을 저장할 수 있는 배열 객체를 만들라는 의미이다.

배열의 사용
-s[0] = 3등의 형식으로 위의 과정을 사용한 이후 사용할 수 있다.
-JAVA에서 배열을 만들 때,배열 객체를 가리킬 참조변수를 만든 후,실제 배열객체를 만들어 사용 해야 한다.

객체배열
-객체배열
	-기본 데이터형 배열을 만드는 것과 동일
	-추가적인 내용이 있음
	-객체배열과 배열객체를 혼동하면 안됨
	-객체배열은 

-객체배열의 이해
	-그림 참조


==========================================
4월 1일 객체지향언어

객체배열
-객체배열은 어떻게 만들 것인가
	-기본 데이터형 배열을 만드는 방법과 동일
	-객체배열과 배열 객체를 혼동 해서는 안된다.
	-객체배열은 배열의 요소로 객체가 저장 되어있는 것을 말하고 배열객체는 배열 자체를 의미

문자 형을 다루는 String 클래스 생성법
1. new 연산자를 이용
2.” ”를 이용

객체배열의 이해
-배열도 객체이다
for(int x = 0; x <- arr.length;x++)
{
	System.out.print(arr[x]);
}
-arr.length라는 표현:배열의 크기를 알아낼 때 사용하는 방법
-배열이 객체임으로 dot( . )으로 표기 가능
-배열과 초기화 동시에 수행하기
	-int []arr = {1,2,3,4,5};
	-String[] arr = {“This”,”is”,”etc”};
	-기본 개념이지만 중요하지 않음.
2차월 배열의 이해
-기본 데이터형을 저장하는 2차원 배열을 도식화한 그림
-2차원 배열에서 각각 1차원 배열들의 길이는 마음대로 크기를 조절해서 만들 수 있다.
-정해진 배열의 길이는 늘이거나 줄일수 없다

String.valueOf();
-다른 형태의 변수를 String형태로 변환한다

System.arraycopy{src .0				tag.0			src.length}
					복사할 배열		복사받을 배열			길이

배열의 크기변경
-배열의 크기가 한번 결정되면,배열의 크기를 줄이거나 늘리는 것은 불가능


==========================================
4월7일 객체지향언어

설계도:붕어빵틀:클래스

집	:   붕어빵	:객체(인스턴스)
(객체 -> 클래스 — 인스턴스화)

실세계의 객체를 흉내내어 클래스를 작성
-추상화
	-명사:속성(property):멤버변수
	-동사:행위(method):멤버 메서드

public/private		class		 ClassName{
//   접근/제한자					클래스 식별자

		명사(<접근자> 데이터형 변수명);//멤버 변수

		동사(<접근자> );//멤버 메서드

		명사 + 동사 = 멤버
}

클래스명 참조변수 = new 클래스명();
//객체의 인스턴스화

생성된 객체의 사용
참조변수.변수;
참조변수.메서드명();

접근제한자(modifiers)
public
protected
default
private


==========================================
4월 8일 객체지향언어

은닉(Encapsulation)
1.클래스 내부의 구현을 숨길 수 있다
2.중요한 데이터를 공개된 메소드를 통해 접근하도록 만든다
3.클래스를 유지보수하기 쉽게 만든다
-다른 클래스에서 이 변수를 절대로 참조할 수 없다
-공개된 메소드를 통해 은닉된 값을 접근할 수 있다
-접근을 위해 도움을 주는 접근자(권한 필요) 	1. Setter - 정리
												2. Getter - 표현

상속(Inheritance)
1.상속 받을때 사용하는 키워드 “extends”는 반드시 기억
2.상속받아 사용하게 되면 재 사용성이 높아진다
3.재 사용성이 높다는 것은 생산성이 높다는 것
4.상속은 다른말로 “Is a Relation”이라고 표현
(ex - “Manager is a Employee”)

상위 클래스— 부모	— SUPER or PARANT
하위 클래스— 자식	— CHILD or SUB

has a relation(상속)
-두 클래스가 서로 다른 관계에서 서로의 멤버변수를 읽으려고 하려면 두 클래스는 관계를 가져야 한다
-A클래스에서 B클래스에 접근하려면 A클래스 안에 B클래스의 참조(referance)만 있으면 된다

다중상속과 단일상속
-상속에는 “단일상속” 과 “다중상속” 두가지가 있다
-JAVA에서는 다중상속을 지원하지 않는다.
(Extends Class1,Class2와 같은것은 불가능하다.)


메서드 재정의(Overriding)
-상속 > 부모의 메소드를 자식클래스에서 다시 정의 하는것(오버라이딩)

생성자 이해하기
-생성자의 특징:반환변수형(return type)이 없고 클래스 이름과 대/소문자 까지 정확히 같은것
-일반적으로 생성자는 멤버변수를 초기화 등에 주로 쓰인다(객체의 초기화에 주로 쓰인다.)
-컴파일러가 생성자가 존재하지 않으면 대신 만들어 준다
-컴파일러가 만든 생성자는 내용이 없는 빈 생성자이다
-명시적으로 생성자를 만들면 컴파일러가 기본 생성자를 만들지 않는다.

중복정의
-특정 클래스의 내부에 같은 이름의 메서드를 정의하는것
-인수의 목록이 달라야 한다(개수가 같으면 타입이 달라야 한다.)

메서드 오버로딩

==========================================
4월 14일 객체지향언어

오버라이딩:상속관계에서 부모로 부터 받은 상속을 재정의

오버로딩:클래스와 이름이 같고 파라미터 이름,갯수,인수값이 틀린 경우

다형성
-이 개념은 은닉(Encapsulation)과 상속(Inheritance)을 모두 잘 알고 있어야만 이해 할 수 있다
-“여러 형태를 가질 수 있다” 혹은 “여러형태로 구현 될 수 있다”라는 의미
(1.부모 클래스의 객체 참조변수에는 자식 객체를 생성하여 할당 할 수 있다.
 2.부모를 가리키는 참조변수는 자식도 가리킬수 있다. - 동물 객체도 참조할 수 있지만 자식객체도 참조가 가능하다
 3.자식에 접근할 때는 부모클래스 명으로 참조를 했을 시 부모로부터 상속받은 객체에만 접근이 가능하다.
 4.자식의 객체에 접근 하기 위해서는 Manager m = (Manager) e 와 같이 강제로 형변환을 해 주면 된다.)

Herero-Genus Collection(이중 콜렉션)
-다형성의 객체를 배열로 저장 하는 것
-부모의 참조변수는 자식이 참조 할 수 있기 때문
-자바의 모든 클래스는 Object라는 클래스를 자동으로 상속 받고 있다.
-자바의 모든 클래스를 담는 배열을 만들 수 있다
-넘어온 객체 타입이 정확히 무엇인지 알아낼때 사용하는 키워드 instanceof

Super키워드
-this는 자기자신의 객체 또는 생성자를 나타낸다
-super은 부모의 객체 또는 부모의 생성자를 나타낸다
-자식이 객체화 될 때 부모의 생성자도 반드시 실행 되어야 한다.
-에러가 발생된는 코드: 부모의 클래스에 기본 생성자가 없다
-부모의 생성자는 상속되지 않는다!
-생성자가 하나라도 있으면 기본 생성자는 컴파일러에서 생성하지 않는다~!
-자식의 생성자 보다 Super의 객체가 앞에 와야만 한다.

==========================================
4월 15일 객체지향언어

패키지
-관련된 클래스들의 묶음
-패키지 안에 또다른 패키지가 놓일수도 있다.
-패키지는 폴더 구조이다
-패키지명은 보통 도메인의 이름을 거꾸로 쓴다

패키지 안의 다른 클래스 사용하기
package x;
import a.b.*;
public class A{
	…
}
-A라는 클래스에서 a,b패키지 안에 있는 모든 클래스 사용
-패키지 안에 있는 클래스의 이름을 언급 할 때 FQN(Fully Qualified Name)을 사용
 (예 - import a.b.A*)
패키지의 종류
-시스템 패키지
	-기본 패키지(JDK)
	-기타 밴더 패키지(.jar - 자바 압축 파일)

접근 제한자
-public(+)
-protected(=)
-default(~)
-private(-)

접근 제한자 접근 범위
접근 제한자			같은 클래스			같은 패키지			자식 클래스			모든 클래스	
public					o					o					o					o	
protected				o					o					o					x
default					o					o					x					x
private					o					x					x					x

접근범위:	public 	>	protected	>	default		>	private
*메인 메서드 (스태틱이 있는 매서드) 내에서의 다른 메서드 사용!
-static은 객체가 생성 되어있지 않아도 실행될 수 있다
-static 영역 내에서 클래스를 실행 시키기 위해서는 클래스를 생성해야만 실행할 수 있다.


==========================================
4월 21일 객체지향언어

클래스 다이어그램
UML(Unified Modeling Language)
-다이어그램을 가지고 객체지향적인 구성을 시각화하여 불수 있기 때문에 관련자 끼리의 의사소통이 쉬워지고
 잘못된 모델링 구조에 대한 검토 및 수정도 용이하게 한다.

클래스 표현
-클래스 다이어그램에서 클래스를 표현할 때는 다음과 같아야 한다.
클래스 이름 - 추상클래스는 이텔릭체,인터페이스는 <<interface>>로 표시
멤버변수(속성) - 멤버변수를 모두 표시
메서드(행위) - 기본적인 getter/setter 생략가능,상속된 메서드도 생략
￼

￼
클래스 관계표현
-클래스간의 관계 밀접도에 따라 대표적인 5가지의 관계를 구분
￼

-Dependency
제공하는 클래스를 필요한 순간에 바로 사용하고 끝내는 정도의 관계
1.반환형
2.메소드의 지역변수 또는 매개변수일때 관계 발생
￼

-Assosiation
서로 다른 생명주기를 가진 클래스끼리 참조하거나 서비스를 요청하는 관계
(기 생성된 두개의 클래스끼리 필요에 의해 메서드등을 통해 참조되는 경우에 해당 )
￼
-Agreegation & Composition
객체와 그 객체를 구성하는 부속물이 되는 객체와의 관계
(부속물을 가지고 있는 객체가 소멸 하여도 부속물이 되는 객체가 소멸하게 되면 Agreegation
  같이 없어질 경우 Composition )

￼

-Generalization
부모클래스의 성질을 자식 클래스가 그대로 물려받아 사용하는 상속관계
￼

패키지 및 인터페이스 표현
￼
추상클래스 표현 및 정적멤버 표현
-클래스 다이어그램에서 추상클래스 및 추상 메서드는 이름을 이탤릭체로 표시하여 나타냄
 (실제로 구현 하여야 함 // 클래스 추상메서드는 메서드에 대한 정의만 한다.)




7장
변수의 범위
1.Static
-모든 인스턴스에서 사용이 가능하다                           
-클래스의 인스턴스화(객체를 만들지 않고 사용이 가능하다)
-static을 다른 메서드에 사용시 클래스명.변수명 으로 사용한다

==========================================
4월22일 객체지향언어

static 키워드
-static 메서드 활용시 오류 발생 상황
-static 메서드가 인스턴스 변수를 참조할 때
￼
(static영역에서 객체를 생성 하지 않고 호출한 예이다. 
static 영역에서는 객체를 무조건 생성 하여 사용하여야 한다.)

main()의 설명

*왜 main은() public인가?
-main()은 프로그램의 시작점
-main()은 누구나 호출이 가능해야 한다

*왜 main()은  static인가?
-main()이 호출되는 시점에 객체(인스턴스)가 만들어진 것이 없다.
-인스턴스 없이도 호출 할 수 있어야 한다.

*main()은 void형 인가?
-JVM은 void type의 main()호출

*argument arg는 무엇인가?
-Java에서 쓰이는 “명령형 인자”

Static 키워드의 기타 설명
1.static initailizer
-클래스가 메모리에 로드될 때 한번만 실행
￼
2.singleton pattern
-하나의 객체만 생성되어 운영되는 것
￼


Fianl
1.클래스에 final사용
-상속 불가능(종단 클래스)

2.메서드에 final사용
-오버라이딩 불가능(종단 메서드)

3.variable변수에 final사용
-상수가 된다.(종단 변수)



추상 클래스
-추상 메서드를 하나이상 가지고 있는 클래스

추상 메서드란?
메서드의 선언 부만 있지 실제 메서드인 body(중괄호)는 없다

추상 클래스
-추상 클래스는 인스턴스를 만들 수 없다

추상 메서드의 사용
-public abstract void func1();
-추상클래스를 사용하려면 추상클래스를 상속받아 새로운 클래스를 만든 후 클래스를 객체화 해아한다
-자식 클래스는 추상메서드를 오버라이딩 하여 반드시 재정의 해야한다

추상 클래스의 용도
-자식클래스에 반드시 구현 하라고 강제시키기 위하여

인터페이스
-인터페이스의 이해
	-추상클래스는 추상메서드 뿐만 아니라 일반 메서드도 가질 수 있다
	-인터페이스라는 것은 일종의 추상클래스
	-인터페이스는 추상 메서드만 가지고 있다.

	-인터페이스는 abstract키워드를 메서드에 사용하지 않아도 abstract 메서드가 된다

	-static final키워드를 변수에 사용하지 않아도 static final변수가 된다

	-interface키워드를 이용하여 선언한다
	-implements 키워드를 이용하여 구현(상속) 한다

	-반드시 자식 클래스에서 구현을 하여야 한다.

	-java의 단일 상속의 한계를 극복


==========================================
4월 29일 객체지향언어

인터페이스의 활용

OOP의 장점:재사용성과 확장성

인터페이스의 활용
-인터페이스:쌍방간의 약속
-tier:티어는 레이어와 비슷한 의미
-tier은 3가지로 나눈다
	1.model
	2.view
	3.controll


==========================================
5월 12일 객체지향언어

Deprecation
-새로운 API가 출시됨에 따라 곧 없어지거나 대체될 API를 말한다

변수의 비교
1. ==를 통한 값의 비교
	-기본 데이터형간의 비교

2..equals()
	-객체들의 참조 주소값이 아닌 내용상의 비교를 할 때 사용(객체간의 비교)
	-Object 클래스가 가진 메서드
	-Object 클래스를 재정의 하고 있다.

toString()의 이해
-객체를 출력하면 가지고 있는 문자열이 출력 된다.
-Object 클래스가 가진 메서드
-toString()을 정의하지 않으면 Object 클래스의 toString()메서드를 실행한다


Inner 클래스
-inner 클래스라는 것은 그 이름 그대로 클래스 안에서 선언된 클래스를 이야기 한다.
-특징:		outer클래스의 메서드를 호출 할 수 있다.
			outer클래스의 인스턴스가 먼저 생성된 후 inner 클래스의 인스턴스가 생성 되어야 한다.
			inner클래스의 이름과  outer클래스의 이름이 달라야 한다.
			inner클래스는 메서드 안에서도 정의 가능하다.
			inner클래스가 메서드 안에 정의시 inner클래스의 지역변수는 상수 이외엔 접근이 불가능 하다.
			추상 inner 클래스의 정의도 가능하다
			inner클래스는 private,default,protected,public 4가지의 modifier가 모두 사용 가능
			inner 클래스는 static으로 정의될 수 있다

Wapper클래스
-Java의 데이터형: 	기본 데이터형
					객체 데이터형

-기본 데이터형을 객체 데이터형으로 변환

StringTokenlizer
-문자열에서 각각의 값들 즉 토큰들을 추출하는 방법을 제공
-“ : ”라는 구분자를 통해 각각의 값들이 모아져 있다.
-CSV: 콤마 세퍼레이트 벨류 - 콤마로 값을 구분 하는 것.

==========================================
5월 13일 객체지향언어

Collection - Data를 저장(순서를 기억 못하고 중복을 허용)
List - 순서 기억,중복 허용
Set - 순서 기억 x,중복 불허
Map -  Key와 Value(Key는 중복 불허하는 Set으로 구현)
	  -  저장된 객체들이 이름과 값의 연관관계를 가지는 콜렉션
Iterator - Collection의 저장된 Data를 꺼내는 기능


Set
-중복 불허,순서 무작위
-set.add(“내용”) 형식으로 추가
￼
*System.out.println(set)이 가능한 이유
-Set.toString()이 상위 객체에서 상속받아 사용되기 때문


List
-중복 허용,순서대로
-list.add(“내용”) 형식으로 추가

Vector

￼
-Vector는 List의 계보
-Vector는 List에서 배열이 꽉 차는 경우 배열을 자동으로 증가시켜준다
-Vector의 요소는 Object 클래스이다.


Map
-Hashtable은 Map인터페이스를 구현(implements)한 클래스
-Hashtable은 Key와 Value의 쌍으로 값을 저장한다.
-데이터 입력에는 hashtable명.put메소드를 사용한다
-Map은 Set으로 구성 되어있기 때문에 중복되어서는 안된다.

Enmeration,Iteration 인터페이스
-Enmeration은  객체를 열거형태로 저장한다
-Iteratiion도 Enmeration과 형태가 같다
-Set 계열의 Collection은 조회를 용이하게 하기위해서 Iterator객체를 제공한다
-둘다 저장된 객체의 처음부터 끝까지 조회하는데 사용 된다.

for-each문
-어떤 배열이 있을때 그 배열의 인덱스를 참조하지 않고 개수를 몰라도 로프를 돌릴 수 있게 해준다. 

==========================================
5월 17일 객체지향언어

제네릭 클래스와 제네릭 메서드
제네릭이란?
-일반적인 코드를 작성하고 이 코드르 다양한 타입의 객체에 대하여 재사용하는 객체지향기법
-제네릭은 특히 ArrayList와 같은 자바 컬렉션 라이브러리에 많이 사용된다

==========================================
5월 19일 객체지향언어

예외란 무엇인가(Exception)
-에러들은 크게 두가지 종류로 나뉜다
	1. 치명적인 에러 : 프로그램이 실행되다 멈춰야만 하는 에러
	2. 에러이긴 하지만 프로그램을 멈풀 필요까지는 없는 에러
-치명적이지 않은 에러(mild error)를 자바에서는 Exception(예외)라고 한다
-Exception도 클래스이다.


try/catch/finally
-try : 무조건 실행되는 블록
-catch : 예외가 발생했을경우 실행되는 블록
-finally: 무조건 실행되는 블록

검사되는 예외(Checked Exception)
-컴파일 시에 예외를 검사하는 경우
1. try/catch/finally를 사용하여 수정한다
2. throws Exception을 사용하여 그냥 종료

검사되지 않는 에외(Unchecked Exception)
-컴파일 시에 예외를 검사하지 않는경우

==========================================
5월 20일 객체지향언어

Call Stack Mechanism
-예외 객체가 호출된 메서드로 이동하는 것
-예외를 처리하는 try/catch 블록을 이용하여 3가지 메서드중 하나에만 존재하면 된다
-throws 키워드를 이용하여 해결 가능(에러에 대해 예외를 예측하여 작성한다.)
-throw는 에러를 발생을 시키는 것이다.
-RuntimeException클래스의 자식 클래스들은 오류처리를 해준다
-“실행 시 발생하는 예외”의 자식 클래스들예외를 맨들 때 ㄸㅌㅊ데샤


사용자 정의 예외
-우리가 직접 예외 클래스를 만들 수 있고, 이를 원하는 시점에 발생시킬 수 있다.

-사용자 정의 예외 클래스 만들기
	-예외를 만들 때 Exception 클래스를 상속받아 만들어야 한다.
	
-사용자 정의 예외 클래스 객체 만들어 사용하기
	-사용자 정의 예외는 직접 발생시켜야 한다
	-예외창을 발생 시킬때 throw를 이용하여 처리

==========================================
9월 22일 객체지향프로그래밍
고급언어와 저급언어의 차이
-컴파일러
-모든 언어는 기계어로 번역 되어야 함

JAVA의 장점
-모든 OS에서 작동이 가능하다(JVM이 있기 때문)
-자바 인코딩 순서
	1.text.java
	2.컴파일러
	3.바이트 코드
	4.JVM
	5.기계어
-JDK과 JRE
	-Java Developement Kit
		-자바를 작성하는 도구 + 개발환경
	-Java Runtime Environment
		-자바를 작성하는 환경을 구동하는 환경
	-JDK안에 JRE가 포함 되어 있다.
-C언어의 작성절차
	1.소스코드
	2.pre-processer
	3.컴파일러
	4.linker(+라이브러리)
	5.결과:exe와 라이브러리
	6.정적 라이브러리 동적 라이브러리
-C언어의 OS독립성
	-전처리기 그리고 라이브러리의 부재
	-결과물이 바이트코드가 아니다.

자바의 단점
-바이트코드를 JVM에 올려 실행해야 하기 때문에 느리다
-NDK(Native Development Kit)
	-Modifier(제어자) - native
	-접근 제어자
		1.public
		2.protected
		3.default
		4.private
	-Static
	-Final
의미:자바의 단점을 보완하기 위해서 C 언어의 코드를 JAVA에 결합하여 
      실행하도록 하는 도구
-보안이 안좋다
	-바이트코드가 노출되어 있다
	-또한 바이트코드를 살릴 수 있다

--------------------------------------------
비구조적 언어	----	저급언어
--------------------------------------------
구조적 언어		----	고급언어
흐름제어 + 함수		
---------------------------------------------
객체지향언어	----	고급언어
클래스를 단위로 재사용성을 높임
(C++,C#,JAVA,PHP)
--------------------------------------------
언어의 발전 이유 : 재사용성

객체지향적 언어
-추상을 사용하는 이유: 무조건 상속을 받아 사용하도록 시키기 위하여
-객체지향적 언어는 구조적 언어의 기능을 안고있다.
-구조적 언어의 구성요소
	1.주석		>>	//,/* */
	2.변수와 상수	>>	선언법
					자료형
					범위
					생명주기
정수와 실수로 나누는 이유
	-정수는 2진수로 나눌 수 있다
	-실수는 근사값으로 저장되기 때문
	-또한 효율성을 위해서 저장방법을 달리 하였기 때문
	-실수:IEEE754 , 정수:2진수 저장	
	3.연산자		>> 기본적으로 알아야 하는 것 - 수식
				>> operater(연산자) && operand(피연산자)
				>>	-	기능				-	산술
										- 	관계
										-	비교
										-	대입
										-	증감
										-	비트
										-	복합
					-	항의개수
					-	순위(잘 모르면 괄호)
	int a = 0;
		if(false &&(a = a+1)){
			System.out.print("1");
		}
	System.out.println(a); 
	  의 경우 &&연산은 모두를 만족해야 하기 때문에 이미 false가 나왔기 때문에 	  더이상 비교하지 않는다
	JAVA에서 기본적으로 정수연산을 하는경우 4byte로 변환된다.
	*php 형변환에 대해서 알아볼 것.
	4.흐름제어문
	5.배열
	6.함수

OOP의 구성요소
-오브젝트 & 클래스(Object & Class)
	-클래스의 기본 요소
		-생성자
		-멤버변수
		-멤버메소드
		-초기화생성자
		-소멸자(자바에서는 없으나 PHP,C++,C#에는 있다)
-상속(Inheritance) - 자바에서는 멤버를 물려받음
-제어자
-다형성
-추상클래스
-인터페이스
-예외처리

==========================================
9월 23일 객체지향프로그래밍
-오브젝트 & 클래스(Object & Class)
	-클래스: 븡어빵 틀
	-오브젝트(객체): 붕어빵
	-클래스의 기본 요소
		-생성자
		-멤버변수
		-멤버메소드
		-초기화생성자
		-소멸자(자바에서는 없으나 PHP,C++,C#에는 있다)
-상속(Inheritance) - 자바에서는 멤버를 물려받음
-제어자(modifier)
-다형성(polipopism)
	-참조변수가 다양한 멤버를 가리킬 수 있다.
-추상클래스	(abstract class)
	-미완성 붕어빵 틀
-인터페이스(interface)
	-객체와 객체를 붙이기 위하여 사용
-예외처리(exception handling)

php의 경우
<?php	
	class student{
		public $name;
		public $age;
		
		function prtInfo($argName,$argAge){
			$this->age =$argAge;
			$this->name = $argName; 
		}
	}
	//$a = new student('김유정,17');
	$stdList[] = new student('김유정',17);
	$stdList[] = new student('박보검',18);
?>
오버로딩
-오버로딩
	-같은 이름의 메소드가 있어도 된다
	-같은 이름의 경우 인자의 갯수 또는 인자의 자료형을 바탕으로 구분한다
	-php의 경우
	<?php
		class student{
			function __construct(){
				echo "cyka";
			}
		}
		$stdList[] = new student();
	?>
	-생성자는 오버로딩이 가능하다
	-하나의 이름을 가진 여러개의 생성자가 생성이 가능하다
	-new 이후 ()를 작성하는 이유는 생성자를 바로 호출하기 위해서 
	-그냥 ()만 사용하면 default 생성자를 사용한다.
	-자바에서 1개 이상의 생성자가 있을경우 default생성자를 만들어주지 않는다.
	-초기화 블럭은 클래스 안에 {}를 사용하여 작성한다
	-초기화 블럭을 사용하면 기본생성자보다 먼저 실행된다
	-초기화 블럭에 static을 사용하면  class의 초기화 블럭이 된다
	-static을 사용하지 않을경우 인스턴스의 초기화 블럭이 된다.
	-php에서는 초기화 블럭이라는 개념이 없다.
	-php에서의 소멸자
	<?php
		function __construct(){
			echo "생성자";
		}
		function __destruct(){
			echo "소멸자";
		}
		$stdList = new student();
		unset($stdList);
		echo "수업 끝,도서관 시청각실로";
	?>


==========================================
9월 27일 객체지향 언어
-오브젝트 & 클래스(Object & Class)
	-클래스: 븡어빵 틀
	-오브젝트(객체): 붕어빵	- 객체는 메모리에 존재함
	-클래스의 기본 요소
		-생성자
		-멤버변수
		-멤버메소드
		-초기화 블럭
		-소멸자(자바에서는 없으나 PHP,C++,C#에는 있다)
-상속(Inheritance) - 자바에서는 멤버를 물려받음
-제어자(modifier)
-다형성(polipopism)
	-참조변수가 다양한 멤버를 가리킬 수 있다.
-추상클래스	(abstract class)
	-미완성 붕어빵 틀
-인터페이스(interface)
	-객체와 객체를 붙이기 위하여 사용
-예외처리(exception handling)

초기화 생성자
-일반 초기화 생성자
-클래스 초기화 생성자
(	static이 붙을 수 있는 것들
	-멤버변수
	-멤버메소드
	-초기화생성자	)

오버로딩과 오버라이딩의 차이
-오버라이딩:부모로부터 상속을 받아 재정의 하는 것
-오버로딩:같은 이름의 메소드를 사용하는 것(인자의 수,자료형이 달라야 한다)
-공통적인 소스코드는 초기화블럭으로 작업한다(교수님이 자주 사용,instance 초기화블럭)
-클래스 초기화 블럭:한번 사용 될 때만 호출되도록 함
-소멸자:자바에서는 garbage collection이 있어서 자동으로 소멸시켜준다.
	-문제는 2가지
	-1.메모리가 계속 쌓여 문제가 발생
	-2.잘못된 접근이 발생한다.

변수의 종류
1.지역변수
2.클래스 멤버변수 	-	객체화 시킬 필요가 없음
3.인스턴스 멤버변수	-	객체화 시킬 필요가 잆음

메소드의 종류
1.클래스 메소드
2.인스턴스 메소드

객체와 인스턴스
-객체 == 인스턴스
-객체화(instanciable)

인스턴스의 생성과 사용
-인스턴스의 생성 방법
	클래스명	참조변수명;			//객체를 다루기 위한 참조변수 선언
	참조변수명	= new 클래스명();		//객체를 생성후 생성된 객체의 주소를 

참조변수에 저장
-참조변수가 가지는 값: 생성된 객체의 주소값을 가지고 있다.
-참조변수가 가지는  용량:주소값이기 때문에 4byte를 가진다
-참조변수를 이용해서 참조변수의 메소드를 불러오는 연산자: '.'


String
-String은 JAVA에서 만들어준 클래스

==========================================
9월 29일 객체지향 언어
-오브젝트 & 클래스(Object & Class)
	-클래스: 븡어빵 틀
	-오브젝트(객체): 붕어빵	- 객체는 메모리에 존재함
	-클래스의 기본 요소
		-생성자
		-멤버변수
		-멤버메소드
		-초기화 블럭
		-소멸자(자바에서는 없으나 PHP,C++,C#에는 있다)
-상속(Inheritance) - 자바에서는 멤버를 물려받음
-제어자(modifier)
-다형성(polipopism)
	-참조변수가 다양한 멤버를 가리킬 수 있다.
-추상클래스	(abstract class)
	-미완성 붕어빵 틀
-인터페이스(interface)
	-객체와 객체를 붙이기 위하여 사용
-예외처리(exception handling)

생성자
-생성자는 프로그래머에 의해서 호출된다
-생성자는 오버로딩이 가능하다.
-하나의 클래스 안에는 1개 이상의 생성자가 존재해야만 한다.
-생성자는 반환형이 없다
-생성자는 클래스와 이름이 동일하다
-생성자가 하나라도 있을경우 자동생성되지 않는다

초기화 블럭
-static이 있을경우 class 초기화 블럭
	-객체를 만들면 처음 만들 때 1번만 생성
-static이 없을경우 instance 초기화 블럭
	-객체를 만들때 마다 생성
-초기화 블럭 생성 시기 : 답이 없다.
-하나의 클래스에 여러개의 생성자를 만들경우 공통된 생성자가 있을경우 초기화 블럭에 사용하면 편하다.

멤버변수
-클래스 안에서 선언 된 변수
-멤버변수를 초기화 하지 않을경우 쓰레기값이 들어간다

*자바의 작성단위는 클래스이다.

참조변수
-4byte로 메모리값을 저장하는 곳
-참조변수에는 class의 주소값을 가져온다.

생성시기
-클래스 변수 	- 클래스가 메모리에 올라갈 때
-인스턴스 변수 	-인스턴스 생성시
-지역변수		-변수선언문 수행시 

클래스 변수 & 인스턴스 변수 생성시기 비교
class my_Class{
	int member_variable _1= 18;
	static member_variable_2 =218;
}

classMainClass{
	System.out.println(member_variable_1);
	System.out.println(member_variable_2);
}

클래스 멤버변수
-멤버변수가 클래스일 경우 모든 메소드에 클래스가 공유가 된다.




/* 오늘 작성한 java파일*/
/*package First;

import java.util.Scanner;																					//scanner를 사용하기 위한 임포트 

class students{																									//클래스 student를 선언 
	int sum = 0;																										//멤버변수 sum을 선언 
	double average = 0.0;																					//멤버변수 average를 선언 

	public int sum(int korean,int english,int math){											//멤버 메소드 sum을 선언하고 가인수(korean,english,math)를 받는다 
		sum = korean+english+math;																		//입력받은 가인수의 값들을 합친다.
		return sum;																									//결과값을 변환 
	}																														//sum 메소드 닫기 
	
	public double average(int sum){																	//출력한 sum의 값을 받아 평균을 내기위한 멤버메소드 선언 
		average = sum / 3.0d;																					//입력받은 sum으로 평균을 구하는 구문 
		return average;																							//결과값을 반환 
	}																														//average 메소드 닫
	
	public void printResult(){																				//결과값을 구하기 위한 멤버 메소드
		Scanner scan = new Scanner(System.in);													//값을 받아오기 위한 라이브러리 
		int std_Num = 0;																							//몇명의 학생의 평균인지를 알기위해 사용한 변수 
			
		System.out.print("학생이 몇명입니까: ");														//학생의 수를 질문하는 print문 
		std_Num = scan.nextInt();																			//std_Num에 scan을 이용하여 입력받는 구문 
		System.out.println();																					//구분을 위한 개행 
		
		String[] name = new String[std_Num];														//이름을 배열로 받아아 인원수 만큼 길이를 만들기 위한 선언 
		int[] korean = new int[std_Num];																//국어 성적을 배열로 입력받아 인원수 만큼 길이를 만들기 위한 선언 
		int[] english = new int[std_Num];																//영어성적을 배열로 입력받아 인원수 만큼 길이를 만들기 위한 선언
		int[] math = new int[std_Num];																	//수학 성적을 배열로 입력받아 인원수 만큼 길이를 만들기 위한 선언
		double [] average = new double[std_Num];												//성적을 배열로 입력받아 인원수만틈 길이를 만들기 위한 선언 
		
		
		
		for(int index=0;index <=std_Num-1;index++){											//배열은 0부터 시작하므로 입력받은 수 보다 1만큼 작아야 하기 때문에 입력받은수 -1로 주었
			System.out.print("이름을 입력하세요: ");													//이름을 입력 하라는 출력
			name[index] = scan.next();																		//이름에 name[0]~name[std_Num-1]까지 입력받는 구문 ,nextLine()을 썼더니 2번째 반복부터 이름을 입력받지 않아버
			System.out.print("국어성적을 입력하세요: ");												//국어성적을 입력하라는 출력문 
			korean[index] = scan.nextInt();																//국어성적에 korean[0]~korean[std_Num-1]까지 입력받는 구문
			System.out.print("영어성적을 입력하세요: ");												//영어성적을 입력하라는 출력문 
			english[index] = scan.nextInt();																//영어성적에 english[0]~english[std_Num-1]까지 입력받는 구문
			System.out.print("수학성적을 입력하세요: ");												//수학성적을 입력하라는 출력문 
			math[index] = scan.nextInt();																	//수학성적에 math[0]~math[std_Num-1]까지 입력받는 구문
			
			System.out.println();																				//구분을 위한 개행 
			
			sum(korean[index],english[index],math[index]);									//한 학생의 성적들을 sum으로 보
			average[index] = average(sum);																//평균 배열에 평균 계산된 값을 집어넣음 
		}																													//계산을 위한 반복문 종료 
		
		for(int i = 0; i <= std_Num-1;i++){																//평균 출력을 위한 반복문 
			System.out.print(name[i]+"의 평균성적: ");												//성적을 출력하기 위한 구문 
			System.out.println(average[i]);																//성적을 출력하는 구문 
		}																													//평균출력 반복문 종료 
	}																														//printResult 멤버메소드 종료 
}																															//클래스 종료 
public class Practice_1 {																					
	public static void main(String[] args) {															
		students std = new students();																	//printResult()메소드를 부르기 위해 선언한 객체 
		std.printResult();																							//std멤버변수의 주소값에서 가지고있는 메소드인 printResult()메소드를 출력 
	}
}
*/
/*교수님이 원한 파일*/
/*
import java.util.Scanner;
// 국영수, 국영수 총합, 국영수 평균, 학생의 이름
// 합계, 평균, 성적 출력
class StudentIndex {
   String StudentName;
   int korean;
   int english;
   int math;
   int sum;
   double average;
   
   public void sumMethod() {
      sum = korean + english + math;
   }
   public void averageMethod() {
      average = sum / 3.0;
   }
   
   public void printMethod() {
      System.out.println("학생의 이름 : " + this.StudentName
             + "총합 : " + this.sum + "평균 : " + this.average);
      
   }
   
}
public class AAAOO {
   public static void main(String[] args) {
      Scanner a = new Scanner(System.in);
      
      System.out.println("학생수를 입력하세요!");
      int rowNum = a.nextInt();
      
      StudentIndex StudentArray[] = new StudentIndex[rowNum];
      
      for(int i = 0; i< StudentArray.length; i++) {
          
          StudentArray[i] = new StudentIndex();
          
          System.out.println("이름을 입력하시오");
           StudentArray[i].StudentName = a.next();
           System.out.println("국어점수 입력하시오");
           StudentArray[i].korean = a.nextInt();
           System.out.println("수학점수를 입력하시오");
           StudentArray[i].math = a.nextInt();
           System.out.println("영어를 입력하시오");
           StudentArray[i].english = a.nextInt();
          
           StudentArray[i].sumMethod();
           StudentArray[i].averageMethod();
          
      }
      
      for(int j = 0; j< StudentArray.length; j++) {
         StudentArray[j].printMethod();
      }
   }
}
*/


==========================================
10월 4일 객체지향 언어

멤버변수
-클래스 맴버변수 : 프로그램이 시작과 동시에 할당 되며 프로그램이 종료되면 사라진다.
			,객체들에게 공유가 가능하다.
			,hip이 아닌 다른 공간에 저장된다,
-인스턴스 멤버변수 : 객체가 생성될 때 만들어지고 객체가 소멸될 때 사라진다.
			 ,서로가 서로에 영향을 주지 않는다.

클래스 맴버변수의 접근방법
-참조변수를 이용해서 접근이 가능하다
-"클래스 명.멤버변수" 의 형태로도 접근이 가능하다.

클래스 멤버변수의 사용
-객체들에 인해서 값이 공유되어야 할 때(예-포커게임의 카드 크기)

메서드
-클래스 멤버 메서드 : 프로그램이 시작과 동시에 올라가서 프로그램 종료까지 사용. 
-인스턴스 멤버 메서드 : 객체가 생성되면 사용이 가능하다.

클래스 맴버메소드의 접근방법
-참조변수를 이용해서 접근이 가능하다
-"클래스 명.멤버메서드" 의 형태로도 접근이 가능하다.
*클래스 안에 클래스가 붙을 경우 이너클래스라고 부름

클래스 메소드에서 불러올 수 있는 것
-클래스 메소드 : 가능
-클래스 멤버변수 : 가능
-인스턴스 메소드 : 불가능
-인스턴스 멤버변수 : 불가능
*클래스 멤버메소드에서 인스턴스 멤버변수,멤버메서드를 불러올 때 객체가 생성 되었는지 아닌지에 대해서 알 수가 없다. 따라서 불러오는 것 자체가 불가능 하다.

-클래스 메소드 : 가능
-클래스 멤버변수 : 가능
-인스턴스 메소드 : 불가능
-인스턴스 멤버변수 : 불가능


==========================================
10월 5일 객체지향 언어
클래스 멤버 - 프로그램이 시작될 때 메모리에 온로드
인스턴스 멤버 - 객체가 생성이 되어야만 사용이 가능

클래스 메소드에서 불러올 수 있는 것
-클래스 메소드 : 가능
-클래스 멤버변수 : 가능
-인스턴스 메소드 : 불가능
-인스턴스 멤버변수 : 불가능
*클래스 멤버메소드에서 인스턴스 멤버변수,멤버메서드를 불러올 때 객체가 생성 되었는지 아닌지에 대해서 알 수가 없다. 따라서 불러오는 것 자체가 불가능 하다.

인스턴스 멤버메소드에서 불러올 수 있는 것
-클래스 메소드 : 가능
-클래스 멤버변수 : 가능
-인스턴스 메소드 : 가능
-인스턴스 멤버변수 : 가능

Call by Value : 파라미터 값만을 넘겨주는 것
Call by Reference : 파라미터의 주소값을 넘겨주는 것
-기본형(원시형) 매개변수
-참조형 매개변수

메인 클래스가 호출될 때에는 test.main()형식으로 호출되며 메인 메소드가 종료될 때에는 프로그램도 종료가 된다.

상수선언법
1.초기화 블록
2.생성자
3.final을 이용
*생성자나 초기화블록 둘중에 하나에서만 선언이 가능

상속 == OOP의 꽃

접근 제어자의 목적
-외부에서 접근하는 객체멤버를 제어하기 위해서
-상속에서 가려서 받기 위해서


===========================================================
조언
1.지금부터 3학년 프로그램에 대한 구상을 하는것이 좋다
2.일상에서 불편했던 것들을 생각해 적어보는 것이 좋다
3.실력이 모자르더라도 자신이 할 일을 찾아라
4.상대방에 대한 배려를 해라
5.주제를 빨리 정해 핵심기술을 미리 공부해 보는 것이 좋다.

==========================================
10월 11일 객체지향 언어

상속(Inheritancce)
-상속을 사용하는 경우:공통된 것이 있을경우
-장점		1.직접적으로 고쳐야 할 코드의 양이 획기적으로 줄어든다
		2.다형성을 이용할 수 있다.
		*다형성:부모가 자신을 상속하여 만든 객체들을 참조할 수 있다(자식,자손 모두)
		3.추상 클래스를 이용할 수 있다.
		*현재 객체에서 구현되지 않아도 되는 객체들을 위해서 사용한다.

==========================================
10월 13일 객체지향 언어
상속(Inheritancce)
-상속을 사용하는 경우:공통된 것이 있을경우
-장점		1.직접적으로 고쳐야 할 코드의 양이 획기적으로 줄어든다
		2.다형성을 이용할 수 있다.
		*다형성:부모가 자신을 상속하여 만든 객체들을 참조할 수 있다(자식,자손 모두)
		3.추상 클래스를 이용할 수 있다.
		*현재 객체에서 구현되지 않아도 되는 객체들을 위해서 사용한다.
UML:Unified Modeling Language
-프로그램을 설계하기위한 언어
클래스 다이어그램
-UML의 다이어그램 중에서 OOP기반의 언어를 설계하기 위해 사용한 것
-Rational Rose Enterprise(클래스 다이어그램 개발 툴)
-Reverse Engineering 소스코드를 클래스다이어그램으로 만듦

단일상속과 다중상속
-자바에서는 단일상속만 가능하지만 C#에서는 다중상속도 가능 하다
-다이아몬드 문제를 해결하기위해 자바에서는 단일상속만을 사용한다.

상속시 고려해야할 것
-생성자
-this,super,참조변수
-오버라이딩
-접근 제어자



조언
편한 곳 
-책임이 따른다

내가 배울 수 있는 곳 
-회사는 학교가 아니라 이익집단이다,내가 스스로 클 수 있는 환경을 제공하는 곳으로 가라.

자신이 정체된다고 느낄 때 
-이력서를 준비하여라 그리고 최소 3년 이상을 그 회사에서 근무 하여라.
-중소 기업의 경우 월급이 그렇게 많이 오르지 않기 때문에 전직을 하며 몸값을 올리는 것이 좋다.

이직을 결심한 경우
 -SNS활동을 멈추어라 그리고 지인에게 조차 회사에 관한 말을 하지 말아라, 부정적인 모습을 보이지 말아라, 나갈때도 나쁜 모습을 보이면 안된다.

회사가 왔을경우
-기업분석에서 복지점수나 홈페이지 만으로 분석하지 마라.
-회사선택의 기준을 나눠라
 1.대기업
	-자랑을 하고싶다
	-대기업의 경우 어디에 배치를 받을지 확실하지 않기 때문

 2.중소기업
	-개발을 하고싶다(라쿠텐 또는 중견기업이나 SI)

==========================================
10월 14일 객체지향언어
상속시 고려해야할 것
-생성자
-this,super,참조변수
-오버라이딩
-접근 제어자

package First;

class a{
	public a(){
		super();
		System.out.println("A 생성자가 호출 되었다.");
	}
}
class b extends a{
	public b(){
		super();
		System.out.println("B 생성자가 호출 되었다.");
	}
	
	public b(String sipal){
		super();
		System.out.println(sipal +" 생성자가 호출 되었다.");
	}
}
class c extends b{
	public c(){
		super();
		System.out.println("C 생성자가 호출 되었다.");
	}
}
public class InheritanceExample {
	public static void main(String args[]){
		new c();
	}
}

여기서 말하는 것은 클래스에서 하나라도 생성자가 있을경우 컴파일러에서 자동으로 생성자를 생성해 주지 않는다.

package First;

class B{
	public B(int sipal){
		System.out.println(sipal);
	}
}
class C extends B {
	int a;
	{
		a = 18;
		System.out.print(a);
	}
	public C(){
		super(2);
		System.out.println("C 생성자 호출");
	}
}
public class Inheritance2 {
	public static void main(String[] args) {

	}

}

이렇게 진행 될 경우 상속이 되어있는 기본 생성자가 먼저 호출이 된 이후 초기화 블록이 호출이 된다.
무조건 부모 생성자의 생성자가 먼저 호출이 되기 때문
생성자가 생성 될 때 부모부터 먼저 생성이 되며 부모의 초기화 작업을 한 이후 자식의 초기화 작업을 하기 때문에 초기화 작업은 불가능 하다.


중간시험
-소스코드를 준다
-문제가 되는것이 5가지가 있다면 거기서 5가지를 찾고 설명을 적어라
-시험일자 10월말 ~ 11월 초

==========================================
10월 20일 객체지향언어
상속시 고려해야할 것
-생성자
-this,super,참조변수
-오버라이딩
-접근 제어자

this는 원래 기본적으로 써야하나 생략이 가능하다
this를 반드시 써야하는 경우가 있는데 이것은 멤버메소드의 지역변수와 멤버변수의 이름이 같을 경우 멤버 변수를 사용하기 위해 this를 사용한다.

this와 super의 차이
-this는 형변환이 가능하다.
다형성
-부모 참조를 선언해 자식객체를 선언할 경우
-만약 부모로부터 자식 객체가 오버라이딩이 되어있다면 동적바인딩을 이용 실 객체가 출력
-오버라이딩 되어있지 않을경우 부모객체가 출력 

오버라이딩
-만약 세번째 자식에서 부모를 호출 할 경우 이러한 형태로 표현이 가능하다
-System.out.println(((College)this).Name);
-방법이 2가지가 있다
	1.완전정의
	2.부분정의
-오버라이딩 시 고민해야 할 것
	1.접근 제어자 - 부모의 접근 제어자보다 자식의 접근 제어자가 같거나 더 커야한다.
	2.예외처리 - 추후 교육



조언: 
-node.js책: 모던 nodejs
-node js 책에서 1~7장 9장 11장만 봐도 된다.
-node.js는 c++로 이루어 져 있으며 사용 언어는 자바스크립트일 뿐이다.
-node.js는 소켓을 미리 구현해 놓아 좀 더 프로그램을 쉽게 하기 위한 것.
-php 책 추천: 뇌를 자극하는 php 프로그래밍

==========================================
10월 25일 객체지향언어

오버라이딩
-부모로부터 상속을 받아 부모로부터 상속받은 메소드를 재정의 하는 것.

재정의 방법
-완전 재정의
-부분 재정의

상속에서 중요한 요소
-접근 제어자의 범위가 부모의 범위보다 크거나 같아야 한다.
-예외처리

상속
-부모로부터 멤버들을 물려 받아 자식 클래스에서 재사용 하는 것.
-재사용성이 높아진다.
-상속을 사용할 때 고려해야하는 요소
	-this : 현재 객체의 멤버에 접근
	-super : 부모 객체의 멤버에 접근
	-생성자 : 부모의 생성자가 먼저 호출 된 이후 자식의 생성자가 호출된다.
	(상위 클래스에 default 생성자가 없는경우 반드시 넣어줘야 한다.)
	-접근 제어자
	-예외처리

package 와 import
package  
-폴더로서 하나의 시스템을 만드는데 기능별로 클래스를 분류하기 위함
-클래스 이름의 중복을 피하기 위해서 사용

import
-클래스명.클래스명.파일 형식으로 사용한다.

객체 선언의 풀 네임과 숏 네임
FULL 네임 선언법
-패키지명.클래스명	 참조변수 	=	패키지명.클래스명();

SHORT 네임 선언법
-클래스명 	참조변수	=	클래스명();	

==========================================
10월 27일 객체지향언어
package  
-폴더로서 하나의 시스템을 만드는데 기능별로 클래스를 분류하기 위함
-클래스 이름의 중복을 피하기 위해서 사용

import
-클래스명.클래스명.파일 형식으로 사용한다.

java 파일
-하나의 파일 안에 .java파일은 무수히 많이 가질 수 있다
-하나의 파일 안에 public class 는 단 하나
	-하나의 패키지가 다른 패키지서 현재 해당 패키지를 당겨 써야 할 겅우 public이 아니면 당길 수 없다.
-외부에서 클래스를 가져다 쓰기 위해서는 public 을 써야 하기 때문에 외부 패키지에서 가져다 쓰는 만큼 .java파일을 생성 해야한다.

접근제어자
접근제어자를 사용하는 곳
-클래스 : public,default
-멤버변수,멤버메소드 : 전부 사용가능
-생성자 : 

접근제어자의 종류
-public
-protected
-default
-private

접근제어자의 사용 목적
-외부에서 객체내의 멤버들을 접근할 수 있느냐 없느냐
-상속과의 관련성(멤버의 사용 가능여부)

접근제어자의 종류
-public : 가장 넓은 사용 범위(전체 사용 가능)
	-public 클래스 에서만 public을 붙여주면 된다.
-protected
-default
	-일반 class에서는 public을 선언하든 private를 선언하든 보이지 않기 때문에 default를 선언하면 된다.
-private : 가장 좁은 사용 범위(상속조차 불가)
	-private사용은 반드시 get/set메소드를 선언 해 줘야한다.
	-싱글톤일 경우 new 연산자로 객체생성을 막고 static 메소드를 이용하여 객체를 선언하게 만듦

질문:
1. 그렇다면 private의 사용은 어떨 때 많이 하게 되는가
(상속 시키지 않기 위해서)
2. public에서 protected는 또 어떨 때 사용을 하게 되는가
(멤버안에 멤버가 protected 라는 의미는 public 클래스라는 이야기이다.)

==========================================
11월 1일 객체지향언어

default : 같은 패키지 내에서는 public과 같은 기능을 가진다
protected : default기능 + 다른패키지에서 상속을 받아 내부에서만 사용 가능

제어자
1. 접근 제어자
2. 그 이외 제어자
	-static : 멤버변수,멤버메소드,초기화 블럭,이너클래스에 사용 가능
	-final :  멤버변수,멤버메소드,클래스 앞에 사용 가능(상속을 거부하기 위해),지역변수에도 사용이 가능
	-abstract : 클래스와 메소드 앞에 사용이 가능


static

final - 클래스: 더이상 변경 될 수 없는 클래스
		메소드 : 더이상 변경 될 수 없는 메소드
		변수 : 상수가 된다

		초기화 방법
		1. 변수 선언과 동시에 초기화
		2. 초기화 블록으로 초기화
		3. 생성자로 초기화

==========================================
11월 3일 객체지향언어

제어자
1. 접근 제어자
2. 그 이외 제어자

static	 -  멤버변수,멤버메소드, 초기화 블록, 이너클래스


final - 멤버변수,멤버메소드,지역변수,클래스


abstract - 클래스 , 메소드,
*추상 메소드가 없더라도 무조건 상속을 받아 써야하는 경우 abstract를 사용한다.

==========================================
11월 8일 객체지향언어

다형성 - 다양한 형태의 성질을 가진다.

자바의 다형성 - 참조변수가 다양한 형태를 가지는 것
(참조변수의 사용 이유 : 객체를 가리키기 위해서)
*참조변수는 자기자신과 같은 자료형만 가리킬 수 있다.

가시성 - 자식의 객체를 선언 하였지만 참조 변수가 부모의 참조 변수일 경우 부모의 객체 까지만 볼 수 있다.

동적 바인딩 : 프로그램의 구성요소가 프로그램이 실행 되면서 결정 되는 것.
자바의 동적 바인딩 : 오버라이딩 된 메소드

동적 바인딩의 필수 요소 : 상속,다양성

다형성을 사용하는 이유 : 서로 다른  자료형을 하나로 관리하기 위해서

==========================================
11월 10일 객체지향언어

추상 클래스
1. 내부 메소드가 추상 메소드 이기 때문에 추상 클래스를 사용
2. 내부 메소드를 무조건적으로 상속받아 사용하기 위함
3. 추상 클래스를 사용하는 이유는 다형성과 연관되어 있다

==========================================
11월 22일 객체지향언어

프로그램의 오류
-런 타임 에러 : 프로그램이 실행 되는 동안 발생하는 에러
-그 이외

런 타임 에러의 종류
-에러 : 예측이 불가능
-예외 : 예측이 가능
* 공통점 : 둘 다 프로그램 실행시 문제가 발생 한다.
* 예외는 예측이 가능해야 한다.

예외처리의 기술 구성 요소
				예외처리

	예외발생				예외처리 기법
	throw					try{
	
	throws				} catch {
							
							} finally {
							
							}

예외 클래스의 계층 구조
			Object
				|
			Throwable
				|
Exception————Error


예외 처리 방법은 3가지
1. 내부에서 처리(try-catch)
2. 메소드 내부에서 반 , 외부에서 반
3. 외부에서 처리

구조적 언어와 OOP의 예외처리의 차이
1. 구조적 언어는 실 소스코드와 예외처리 소스코드가 구분이 되지 않는다
2. 객체지향 언어는 소스코드와 예외처리 소스코드가 구분이 가능하다

* unchecked 예외는 throw를 할 필요가 없다(ex - RuntimeException)

==========================================
11월 24일 객체지향언어

예외처리 과정
1. 예외 생성 Exception = new Exception();  try{  } catch (Exception e) {  }
2. 예외 발생 throw throws
3. 예외 처리 try{  } catch(Exception e) {  } finally {  } 
* throw는 unchecked의 경우 명시하지 않는다
* throw는 checked의 경우 반드시 명시한다

==========================================
11월 29일 객체지향언어

try-catch문
-try 문 안에서 예외가 발생하면 더이상 try문은 실행되지 않고 try문에서 빠져나오게 된다.
-예외 catch문의 순서는 Exception이 가장 큰 객체이기 때문에 여러개를 써야 할 경우 Exception을 먼저 써서는 안된다.


try - with - resources

class A01 implements AutoCloseable{
	public void close() throws Exception{
		System.out.println("자원 반납");
	}
}

public class ExceptionEx3 {
	public static void main(String[] args) {
		System.out.println(1);
		try(A01 varA = new A01()){
			System.out.println(2);
			if(2 > 3){
				System.out.println(3);
				throw new IOException();
			}
		} catch(Exception e) {
			System.out.println(8);
		}
		System.out.println(10);
	}
}

	public static void main(String[] args) {
		System.out.println(1);
		try(A01 varA = new A01();
			  A01 varB = new A01){
			System.out.println(2);
			if(2 > 3){
				System.out.println(3);
				throw new IOException();
			}
		} catch(Exception e) {
			System.out.println(8);
		}
		System.out.println(10);
	}
}

==========================================
12월 1일 객체지향언어

내부클래스(Inner Class)란?
-클래스 내부에 클래스를 선언 하는 것

내부 클래스를 사용하는 이유
-해당 클래스에서만 사용해야 하는 클래스의 경우 내부 클래스를 선언한다.
-내부 클래스에서 외부 클래스의 멤버를 직접적으로 이용할 수 있다.

내부 클래스의 종류(2가지 종류로 구분)
-Inner class (None Static Nested	Class)
	-종속관계(외부 클래스와 내부클래스의 관계가 종속 관계이다)
-Static Nested Class
	-수평관계(외부 클래스와 내부 클래스의 관계가 수평관계이다)

내부에서의 외부 접근
-제약이 없다.

외부에서의 내부 접근
-불가능하다
-이유: 내부 클래스가 만들어질 지 만들어지지 않을지에 대한 모호성이 있기 때문

메소드 안에서 선언 된 내부 클래스
-지역 클래스 라고 한다.
-지역 클래스는 해당 메소드 안에서만 사용이 가능하다.

==========================================
12월 8일 객체지향언어

Nested class
1)Non-static nested class or inner class
	->종속 관계

2)static nested class
	->수평관계


Static nested class 에서 외부클래스의 변수를 내부클래스가 사용하지 못하는 이유
-외부클래스의 객체가 만들어질지 안 만들어질지 알 수가 없기 때문


Static nested class를 사용하는 이유
-서로 연관된 클래스들 별로 묶을 때 사용
-패키지 보다 작은 단위로 묶기위해서 사용하는 것이다.

익명객체
-이름없는 클래스를 정의함과 동시에 객체화 하는 것
-사용법 : new 인터페이스 or 클래스명(){
				//메소드
			};
interface cya{
	abstract public void prt();
}

public class nonane{
	public static void main(String args[]){
		cya varC = new cyka(){
			public void prt(){
				//인터페이스 객체를 만들기와 동시에 추상 메소드를 구현
				//클래스의 정의와 동시에 구현
			}
		};
	}
}
